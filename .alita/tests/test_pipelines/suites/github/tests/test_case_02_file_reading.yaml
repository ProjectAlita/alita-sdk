name: "GH02 - File Reading Workflow"
description: "Test file reading operations: list files in branch, get files from directory, read file content"

toolkits:
  - id: ${GITHUB_TOOLKIT_ID}
    name: ${GITHUB_TOOLKIT_NAME}

state:
  directory_path:
    type: str
    value: test-data
  expected_content:
    type: str
    value: .DS_Store
  file_content:
    type: str
  file_to_read:
    type: str
  files_in_branch:
    type: str
  files_in_directory:
    type: str
  input:
    type: str
  known_file:
    type: str
    value: .gitignore
  messages:
    type: list
  test_results:
    type: dict
  tool_result:
    type: str
  trimmed_branch_data:
    type: dict
  trimmed_dir_file:
    type: dict
  validation_results:
    type: dict

entry_point: list_files_in_branch

nodes:
  - id: list_files_in_branch
    type: toolkit
    input: []
    input_mapping: {}
    output:
      - files_in_branch
    structured_output: true
    tool: list_files_in_main_branch
    toolkit_name: ${GITHUB_TOOLKIT_NAME}
    transition: trim_branch_files

  - id: trim_branch_files
    type: code
    code:
      type: fixed
      value: |
        import json
        raw = alita_state.get("files_in_branch", "")
        known = alita_state.get("known_file", ".gitignore")
        files = []
        try:
            if isinstance(raw, list):
                files = raw
            elif isinstance(raw, str):
                files = json.loads(raw)
        except Exception:
            pass
        file_paths = [f if isinstance(f, str) else str(f) for f in files]
        data = {"list_branch_files": len(file_paths) > 0, "branch_files_count": len(file_paths), "has_known_file": known in file_paths, "branch_files_sample": file_paths[:10]}
        {"trimmed_branch_data": data}
    input:
      - files_in_branch
      - known_file
    output:
      - trimmed_branch_data
    structured_output: true
    transition: get_files_from_directory

  - id: get_files_from_directory
    type: toolkit
    input:
      - directory_path
    input_mapping:
      directory_path:
        type: variable
        value: directory_path
    output:
      - files_in_directory
    structured_output: true
    tool: get_files_from_directory
    toolkit_name: ${GITHUB_TOOLKIT_NAME}
    transition: trim_dir_and_pick_file

  - id: trim_dir_and_pick_file
    type: code
    code:
      type: fixed
      value: |
        import json
        raw = alita_state.get("files_in_directory", "")
        dir_path = alita_state.get("directory_path", "test-data")
        branch_data = alita_state.get("trimmed_branch_data", {})
        files = []
        try:
            if isinstance(raw, list):
                files = raw
            elif isinstance(raw, str):
                files = json.loads(raw)
        except Exception:
            pass
        file_paths = [f if isinstance(f, str) else str(f) for f in files]
        file_to_read = None
        for fp in file_paths:
            if fp.endswith(".txt") or fp.endswith(".md"):
                file_to_read = fp
                break
        if file_to_read is None and file_paths:
            file_to_read = file_paths[0]
        vr = {
            "list_branch_files": branch_data.get("list_branch_files", False),
            "branch_files_count": branch_data.get("branch_files_count", 0),
            "has_known_file": branch_data.get("has_known_file", False),
            "branch_files_sample": branch_data.get("branch_files_sample", []),
            "list_dir_files": len(file_paths) > 0,
            "dir_files_count": len(file_paths),
            "dir_files_sample": file_paths[:10],
            "directory_path": dir_path
        }
        {"validation_results": vr, "file_to_read": file_to_read}
    input:
      - files_in_directory
      - directory_path
      - trimmed_branch_data
    output:
      - validation_results
      - file_to_read
    structured_output: true
    transition: read_known_file

  - id: read_known_file
    type: toolkit
    input:
      - known_file
    input_mapping:
      file_path:
        type: variable
        value: known_file
    output:
      - file_content
    structured_output: true
    tool: read_file
    toolkit_name: ${GITHUB_TOOLKIT_NAME}
    transition: trim_known_file

  - id: trim_known_file
    type: code
    code:
      type: fixed
      value: |
        content = alita_state.get("file_content", "")
        expected = alita_state.get("expected_content", "")
        prev = alita_state.get("validation_results", {})
        if isinstance(content, str):
            has_content = len(content) > 0
            has_expected = expected in content
            content_len = len(content)
        else:
            has_content = False
            has_expected = False
            content_len = 0
        updated = dict(prev) if isinstance(prev, dict) else {}
        updated["read_known_file"] = has_content
        updated["known_file_has_expected"] = has_expected
        updated["known_file_length"] = content_len
        {"validation_results": updated}
    input:
      - file_content
      - expected_content
      - validation_results
    output:
      - validation_results
    structured_output: true
    transition: read_directory_file

  - id: read_directory_file
    type: toolkit
    input:
      - file_to_read
    input_mapping:
      file_path:
        type: variable
        value: file_to_read
    output:
      - file_content
    structured_output: true
    tool: read_file
    toolkit_name: ${GITHUB_TOOLKIT_NAME}
    transition: trim_dir_file

  - id: trim_dir_file
    type: code
    code:
      type: fixed
      value: |
        import json
        content = alita_state.get("file_content", "")
        file_path = alita_state.get("file_to_read", "")
        prev = alita_state.get("validation_results", {})
        dir_file_len = len(content) if isinstance(content, str) else 0
        dir_file_read = dir_file_len > 0
        summary = {
            "validation_results": prev,
            "dir_file_path": file_path,
            "dir_file_length": dir_file_len,
            "dir_file_read": dir_file_read
        }
        {"trimmed_dir_file": summary}
    input:
      - file_content
      - file_to_read
      - validation_results
    output:
      - trimmed_dir_file
    structured_output: true
    transition: process_results

  - id: process_results
    type: llm
    input:
      - trimmed_dir_file
    input_mapping:
      chat_history:
        type: fixed
        value: []
      system:
        type: fixed
        value: You are a quality assurance validator.
      task:
        type: fstring
        value: |
          Analyze the pre-processed results from the file reading workflow.

          Summary Data: {trimmed_dir_file}

          The summary contains:
          - validation_results.list_branch_files: bool
          - validation_results.branch_files_count: int
          - validation_results.has_known_file: bool
          - validation_results.list_dir_files: bool
          - validation_results.dir_files_count: int
          - validation_results.read_known_file: bool
          - validation_results.known_file_has_expected: bool
          - validation_results.known_file_length: int
          - dir_file_path: string
          - dir_file_length: int
          - dir_file_read: bool

          Test passes if: list_branch_files is true AND read_known_file is true.
          Directory operations are bonus (may fail if test-data does not exist).

          Do NOT echo back the full summary. Keep response under 300 tokens.

          Return a JSON object named test_results with the following structure:

          {{
            "test_passed": boolean (true if validation_results.list_branch_files AND validation_results.read_known_file are both true),
            "operations": {{
              "list_files_in_main_branch": boolean,
              "get_files_from_directory": boolean,
              "read_known_file": boolean,
              "read_directory_file": boolean
            }},
            "details": {{
              "branch_files_count": integer,
              "dir_files_count": integer,
              "known_file_length": integer,
              "dir_file_path": string,
              "dir_file_length": integer
            }},
            "error": string | null
          }}

          Return **EXACTLY** **NONNEGOTIATABLE** only the `test_results` JSON object. Do not use markdown ```json when returning the json. Do not include any explanations, summaries, or additional text.
    model: gpt-4o
    output:
      - test_results
    structured_output_dict:
      test_results: dict
    transition: END