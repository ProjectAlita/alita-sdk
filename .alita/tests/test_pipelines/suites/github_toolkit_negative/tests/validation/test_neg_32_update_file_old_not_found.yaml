# NEG_21: Update File OLD Content Not Found
# Verifies that update_file returns actionable error when OLD content doesn't exist in file
# Expected: Clear error about content not found in file

name: "NEG21 - Update File OLD Content Not Found"
description: "Verify update_file returns actionable error when OLD content doesn't match file"

toolkits:
  - id: ${GITHUB_TOOLKIT_ID}
    name: ${GITHUB_TOOLKIT_NAME}

state:
  input:
    type: str
  messages:
    type: list
  file_query:
    type: str
  tool_result:
    type: str
  test_results:
    type: dict

entry_point: prepare_nonmatching_query

nodes:
  - id: prepare_nonmatching_query
    type: code
    code:
      type: fixed
      value: |
        nl = chr(10)
        # Try to update README.md with content that doesn't exist
        file_query = "README.md" + nl
        file_query += "OLD <<<<" + nl
        file_query += "this content definitely does not exist in the readme file xyz123abc456" + nl
        file_query += ">>>> OLD" + nl
        file_query += "NEW <<<<" + nl
        file_query += "replacement content" + nl
        file_query += ">>>> NEW"

        {"file_query": file_query}
    input: []
    output:
      - file_query
    structured_output: true
    transition: invoke_update

  - id: invoke_update
    type: toolkit
    tool: update_file
    toolkit_name: ${GITHUB_TOOLKIT_NAME}
    input:
      - file_query
    input_mapping:
      file_query:
        type: variable
        value: file_query
    output:
      - tool_result
    structured_output: true
    transition: validate_error

  - id: validate_error
    type: code
    code:
      type: fixed
      value: |
        result = alita_state.get('tool_result')
        result_str = str(result).lower() if result else ''

        # Should indicate content not found
        has_not_found = any(term in result_str for term in [
            'not found', 'not exist', 'no match', 'could not find',
            'doesn\'t exist', 'does not exist', 'unable to find',
            'content', 'old', 'match'
        ])

        no_traceback = 'traceback' not in result_str
        not_success = 'updated' not in result_str or 'error' in result_str or 'failed' in result_str or 'not found' in result_str
        is_concise = len(result_str) < 1000

        # Should suggest what to do (read file first, verify content)
        is_actionable = any(term in result_str for term in [
            'read', 'verify', 'check', 'content', 'file'
        ])

        test_passed = has_not_found and not_success and no_traceback

        test_results = {
            "test_passed": test_passed,
            "error_quality": {
                "indicates_not_found": has_not_found,
                "is_actionable": is_actionable,
                "no_raw_traceback": no_traceback,
                "not_success_response": not_success,
                "is_concise": is_concise
            },
            "actual_response": result_str[:500],
            "improvement_needed": [] if test_passed else [
                "Missing 'not found' indicator" if not has_not_found else None,
                "Error not actionable" if not is_actionable else None,
                "Contains raw traceback" if not no_traceback else None,
                "Incorrectly indicates success" if not not_success else None
            ]
        }
        test_results["improvement_needed"] = [x for x in test_results["improvement_needed"] if x]
        test_results
    input:
      - tool_result
    output:
      - messages
    structured_output: false
    transition: END
