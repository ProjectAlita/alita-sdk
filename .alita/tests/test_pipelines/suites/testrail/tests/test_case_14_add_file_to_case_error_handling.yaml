name: "TR14 add file error"
priority: High
description: |
  Verify the add_file_to_case tool handles invalid file paths gracefully.
  
  Objective: Test error handling for non-existent artifact.
  
  Expected Behavior:
  - Tool executes without crashing
  - Returns appropriate error for missing file
  - Error indicates file not found or download failed

toolkits:
  - id: ${TESTRAIL_TOOLKIT_ID}
    name: ${TESTRAIL_TOOLKIT_NAME}

state:
  section_id:
    type: str
    value: ${TESTRAIL_SECTION_ID}
  case_id:
    type: str
  created_case_id:
    type: str
  filepath:
    type: str
    value: "nonexistent-file-tr14.txt"
  filename:
    type: str
    value: "missing-file.txt"
  tool_result:
    type: dict
  test_results:
    type: dict
  cleanup_result:
    type: str

entry_point: create_testcase

nodes:
  - id: create_testcase
    type: toolkit
    tool: add_case
    toolkit_name: ${TESTRAIL_TOOLKIT_NAME}
    input:
      - section_id
    input_mapping:
      section_id:
        type: variable
        value: section_id
      title:
        type: fixed
        value: "[Auto] Test Case for TR14 - File Error Test"
      case_properties:
        type: fixed
        value:
          template_id: 1
          type_id: 1
          priority_id: 2
    output:
      - tool_result
    structured_output: true
    transition: extract_case_id

  - id: extract_case_id
    type: code
    code:
      type: fixed
      value: |
        import json
        
        tool_result = alita_state.get("tool_result", "")
        created_case_id = ""
        
        try:
            result_dict = json.loads(tool_result) if isinstance(tool_result, str) else tool_result
            if 'id' in result_dict:
                created_case_id = str(result_dict['id'])
        except:
            pass
        
        {"created_case_id": created_case_id, "case_id": created_case_id}
    input:
      - tool_result
    output:
      - created_case_id
      - case_id
    structured_output: true
    transition: invoke_add_file_to_case

  - id: invoke_add_file_to_case
    type: toolkit
    tool: add_file_to_case
    toolkit_name: ${TESTRAIL_TOOLKIT_NAME}
    input:
      - case_id
      - filepath
      - filename
    input_mapping:
      case_id:
        type: variable
        value: case_id
      filepath:
        type: variable
        value: filepath
      filename:
        type: variable
        value: filename
    output:
      - tool_result
    structured_output: true
    transition: delete_testcase

  - id: delete_testcase
    type: toolkit
    tool: delete_case
    toolkit_name: ${TESTRAIL_TOOLKIT_NAME}
    input:
      - created_case_id
    input_mapping:
      case_id:
        type: variable
        value: created_case_id
      soft_delete:
        type: fixed
        value: true
    output:
      - cleanup_result
    structured_output: false
    continue_on_error: true
    transition: validate_result

  - id: validate_result
    type: llm
    model: gpt-4o-2024-11-20
    input:
      - tool_result
      - cleanup_result
    input_mapping:
      system:
        type: fixed
        value: "You are a quality assurance validator."
      task:
        type: fstring
        value: |
          Analyze the complete test workflow results.

          File Attachment Result: {tool_result}
          Cleanup Result: {cleanup_result}

          This test validates error handling for non-existent artifact file AND verifies cleanup.

          Perform the following checks:
          1. File Attachment Error Validation:
             - Confirm the tool executed (result is not empty or null).
             - Examine any error message for specific meaning. Valid error patterns for missing file include:
               * file not found or does not exist
               * failed to download artifact
               * artifact not accessible
               * file path invalid
             - Determine if the error is about the missing file itself.
               Errors like "failed to download artifact" are expected and correct.
               System errors unrelated to the file path are failures.
          
          2. Cleanup Verification:
             - Verify the cleanup (delete_case) was attempted.
             - Check if cleanup result indicates successful deletion.
             - Note: Cleanup errors can be ignored, but attempt must be made.

          Return a JSON object named test_results with the following structure:

          {{
            "test_passed": boolean (TRUE if error occurred as expected AND cleanup was attempted),
            "summary": "brief description of outcome including cleanup status",
            "error": "error details if failed, null if passed"
          }}

          Return **ONLY** the JSON object. No markdown, no additional text.
      chat_history:
        type: fixed
        value: []
    output:
      - test_results
    structured_output_dict:
      test_results: "dict"
    transition: END
