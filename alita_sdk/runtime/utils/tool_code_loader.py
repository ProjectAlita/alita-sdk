"""
Static Tool Code Loader

Loads pre-generated tool code documentation from markdown files.
This replaces runtime AST parsing with static file loading for better performance.

The markdown files are generated by generate_tool_code_docs.py script.

Usage:
    from alita_sdk.runtime.utils.tool_code_loader import load_tool_code

    tool_code = load_tool_code('github_create_issue', 'github')
    if tool_code:
        print(tool_code)
"""

import logging
from functools import lru_cache
from pathlib import Path
from typing import Optional

logger = logging.getLogger(__name__)

# LRU cache size for tool code loading
CACHE_SIZE = 100


@lru_cache(maxsize=CACHE_SIZE)
def load_tool_code(tool_name: str, toolkit_type: Optional[str] = None) -> Optional[str]:
    """
    Load pre-generated tool code documentation from markdown file.

    Args:
        tool_name: Name of the tool (e.g., 'github_create_issue', 'create_issue')
        toolkit_type: Type of toolkit (e.g., 'github', 'ado_repos')

    Returns:
        Tool code documentation as string, or None if not found

    Example:
        >>> code = load_tool_code('create_issue', 'github')
        >>> if code:
        ...     print(code)
    """
    try:
        # Infer toolkit_type from tool_name if not provided
        if not toolkit_type:
            toolkit_type = _infer_toolkit_type(tool_name)

        if not toolkit_type:
            logger.debug(f"Cannot infer toolkit type for tool '{tool_name}'")
            return None

        # Extract method name from tool name
        method_name = _extract_method_name(tool_name, toolkit_type)

        # Try to load from pre-generated markdown file
        tool_code = _load_from_markdown(toolkit_type, method_name)

        if tool_code:
            logger.debug(f"Loaded tool code for '{tool_name}' from static docs ({len(tool_code)} chars)")
            return tool_code
        else:
            logger.debug(f"Tool code not found for '{tool_name}' (toolkit: {toolkit_type}, method: {method_name})")
            return None

    except Exception as e:
        logger.warning(f"Failed to load tool code for '{tool_name}': {e}", exc_info=True)
        return None


def _infer_toolkit_type(tool_name: str) -> Optional[str]:
    """
    Infer toolkit type from tool name.

    Args:
        tool_name: Tool name like 'github_create_issue'

    Returns:
        Toolkit type like 'github', or None if cannot infer
    """
    # Common pattern: toolkit_action or toolkit_noun_action
    if '_' in tool_name:
        parts = tool_name.split('_')
        # Use first part as toolkit unless it's a common verb
        common_verbs = {'get', 'set', 'create', 'update', 'delete', 'list', 'search', 'add', 'remove'}
        if parts[0].lower() not in common_verbs:
            return parts[0]

    return None


def _extract_method_name(tool_name: str, toolkit_type: str) -> str:
    """
    Extract method name from tool name.

    Handles special cases:
    - 'ado_repos_create_pr' with toolkit 'ado_repos' -> 'create_pr'
    - 'github_create_issue' with toolkit 'github' -> 'create_issue'

    Args:
        tool_name: Full tool name like 'github_create_issue' or 'ado_repos_create_pr'
        toolkit_type: Toolkit type like 'github' or 'ado_repos'

    Returns:
        Method name like 'create_issue' or 'create_pr'
    """
    # Remove toolkit prefix if present
    if tool_name.startswith(f"{toolkit_type}_"):
        return tool_name[len(toolkit_type) + 1:]

    # For ADO sub-toolkits, also try removing just 'ado_' if toolkit_type starts with it
    if toolkit_type.startswith('ado_'):
        # Try removing the full ado_subtoolkit prefix
        if tool_name.startswith(f"{toolkit_type}_"):
            return tool_name[len(toolkit_type) + 1:]

        # Also try if tool doesn't have the full prefix
        sub_toolkit = toolkit_type[4:]  # ado_repos -> repos
        if tool_name.startswith(f"{sub_toolkit}_"):
            return tool_name[len(sub_toolkit) + 1:]

    return tool_name


def _load_from_markdown(toolkit_type: str, method_name: str) -> Optional[str]:
    """
    Load tool code from pre-generated markdown file.

    Args:
        toolkit_type: Toolkit type (e.g., 'github', 'ado_repos')
        method_name: Method name (e.g., 'create_issue')

    Returns:
        Tool code documentation as string, or None if not found
    """
    try:
        # Get path to docs/code directory
        current_file = Path(__file__)
        sdk_root = current_file.parent.parent.parent  # Go up to alita_sdk/
        docs_dir = sdk_root / 'docs' / 'code'  # Go to docs/code/

        # Markdown filename format: toolkit__method.md
        md_file = docs_dir / f"{toolkit_type}__{method_name}.md"

        if not md_file.exists():
            logger.debug(f"Tool code file not found: {md_file}")
            return None

        with open(md_file, 'r', encoding='utf-8') as f:
            content = f.read().strip()

        if content:
            logger.debug(f"Loaded tool code from {md_file.name} ({len(content)} chars)")
            return content

        return None

    except Exception as e:
        logger.debug(f"Error loading markdown for '{toolkit_type}__{method_name}': {e}")
        return None


def clear_cache() -> None:
    """Clear the tool code cache. Useful for testing."""
    load_tool_code.cache_clear()
    logger.info("Tool code cache cleared")


def get_cache_info() -> dict:
    """
    Get cache statistics.

    Returns:
        Dictionary with cache info (hits, misses, size, maxsize)
    """
    cache_info = load_tool_code.cache_info()
    return {
        'hits': cache_info.hits,
        'misses': cache_info.misses,
        'size': cache_info.currsize,
        'maxsize': cache_info.maxsize
    }

