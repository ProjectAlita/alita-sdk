name: Test Runner Reusable
run-name: Executing test for ${{ inputs.test_cases_dir }} on ${{ inputs.environment }} 

on:
  workflow_call:
    inputs:
      test_cases_dir:
        description: 'Test cases directory (e.g., github, ado, confluence)'
        required: true
        type: string
      environment:
        description: 'Environment to run tests in (local or other)'
        required: false
        type: string
        default: 'local'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test-execution:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Docker Compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull Docker image
        run: |
          IMAGE_NAME=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          docker pull ${{ env.REGISTRY }}/$IMAGE_NAME:pyodide

      - name: Calculate and run test command
        run: |
          ENV_FLAG=$([ "${{ inputs.environment }}" = "local" ] && echo "--local" || echo "")
          TEST_COMMAND="/app/.alita/tests/test_pipelines/run_all_suites.sh $ENV_FLAG -v suites/${{ inputs.test_cases_dir }}"
          
          echo "DOCKER_COMMAND_COMPOSED=$TEST_COMMAND" >> $GITHUB_ENV  
          echo "Running test command: $TEST_COMMAND"         

      - name: Uppercase the environment
        id: set-api-key
        run: |
          if [ "${{ inputs.environment }}" = "local" ]; then
            ENV_UPPER="DEV"
          else
            ENV_UPPER=$(echo "${{ inputs.environment }}" | tr '[:lower:]' '[:upper:]')
          fi
          echo "ENV_UPPER=${ENV_UPPER}" >> $GITHUB_ENV

      - name: Run docker-compose
        run: |
          echo "::notice::Starting docker-compose with command: ${{ env.DOCKER_COMMAND_COMPOSED }}"
          echo "::notice::On environment: ${{ env.ENV_UPPER }}"
          export DEPLOYMENT_URL="${{ secrets[format('DEPLOYMENT_URL_{0}', env.ENV_UPPER )] }}"
          export ALITA_API_KEY="${{ secrets[format('ALITA_API_KEY_{0}', env.ENV_UPPER )] }}"
          export PROJECT_ID="${{ secrets[format('PROJECT_ID_{0}', env.ENV_UPPER )] }}"
          export GIT_TOOL_ACCESS_TOKEN="${{ secrets.GIT_TOOL_ACCESS_TOKEN }}"
          export CONFLUENCE_API_KEY="${{ secrets.CONFLUENCE_API_KEY }}"
          export CONFLUENCE_BASE_URL="${{ secrets.CONFLUENCE_BASE_URL }}"
          export CONFLUENCE_USERNAME="${{ secrets.CONFLUENCE_USERNAME }}"
          export ADO_TOKEN="${{ secrets.ADO_TOKEN }}"
          export ADO_REPOSITORY_ID="${{ secrets.ADO_REPOSITORY_ID }}"
          export ADO_ORGANIZATION_URL="${{ secrets.ADO_ORGANIZATION_URL }}"
          export ADO_PROJECT="${{ secrets.ADO_PROJECT }}"
          export JIRA_API_KEY="${{ secrets.JIRA_API_KEY }}"
          export JIRA_USERNAME="${{ secrets.JIRA_USERNAME }}"
          export JIRA_BASE_URL="${{ secrets.JIRA_BASE_URL }}"
          export FIGMA_API_TOKEN="${{ secrets.FIGMA_API_TOKEN }}"
          export BITBUCKET_TOKEN="${{ secrets.BITBUCKET_TOKEN }}"
          export XRAY_CLIENT_SECRET="${{ secrets.XRAY_CLIENT_SECRET }}"
          export XRAY_CLIENT_ID="${{ secrets.XRAY_CLIENT_ID }}"
          export ZEPHYR_ESENTIALS_KEY="${{ secrets.ZEPHYR_ESENTIALS_KEY }}"
          export GITLAB_PRIVATE_TOKEN="${{ secrets.GITLAB_PRIVATE_TOKEN }}"
          export JIRA_PROJECT="EL"
          export TEST_CASES_DIR="${{ inputs.test_cases_dir}}"
          export ENVIRONMENT="${{ inputs.environment }}"
          export DOCKER_COMMAND="${{ env.DOCKER_COMMAND_COMPOSED }}"
          export ENV_NAME="${{ inputs.environment }}"
          docker-compose up -d

      - name: Wait for tests to complete
        run: |
          echo "Waiting for test execution to complete..."
          
          TIMEOUT=10000
          ELAPSED=0
          INTERVAL=20
          CONTAINER_EXIT_CODE=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            STATUS=$(docker inspect alita-sdk-dev --format='{{.State.Status}}' 2>/dev/null || echo "not-found")
            
            if [ "$STATUS" = "exited" ]; then
              EXIT_CODE=$(docker inspect alita-sdk-dev --format='{{.State.ExitCode}}')
              CONTAINER_EXIT_CODE=$EXIT_CODE
              echo "Container exited with code: $EXIT_CODE"
              
              if [ "$EXIT_CODE" -eq 0 ]; then
                echo "âœ… Container completed successfully"
              else
                echo "âŒ Container exited with error code $EXIT_CODE"
              fi
              
              echo "Container logs:"
              docker-compose logs alita-sdk
              break
            elif [ "$STATUS" = "running" ]; then
              echo "Container still running... ($ELAPSED seconds elapsed)"
              echo "::group:: Current logs"
              docker-compose logs alita-sdk --tail=50
              echo "::endgroup::"
            else
              echo "Container status: $STATUS"
            fi
            
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "âš ï¸ Timeout reached after $TIMEOUT seconds"
            docker-compose logs alita-sdk
            exit 1
          fi
          
          if [ $CONTAINER_EXIT_CODE -ne 0 ]; then
            echo "::error::Tests failed with exit code $CONTAINER_EXIT_CODE"
            exit $CONTAINER_EXIT_CODE
          fi

      - name: Copy test results
        if: always()
        run: |
          docker cp alita-sdk-dev:/app/.alita/tests/test_pipelines/test_results/suites/${{ inputs.test_cases_dir }}/results.json ./results.json || echo "{}" > ./results.json
          
      - name: Generate test report
        if: always()
        run: |
          echo "Generating test report..."
          python .alita/tests/test_pipelines/scripts/generate_report.py ./results.json

      - name: Print execution summary
        if: always()
        run: |
          if [ ! -f ./results.json ]; then
            echo "âŒ No results.json found - tests may not have completed"
            if [ -n "$GITHUB_STEP_SUMMARY" ]; then
              echo "" >> "$GITHUB_STEP_SUMMARY"
              echo "## âŒ Test Results" >> "$GITHUB_STEP_SUMMARY"
              echo "" >> "$GITHUB_STEP_SUMMARY"
              echo "âŒ No results.json found - tests may not have completed" >> "$GITHUB_STEP_SUMMARY"
            fi
            exit 1
          fi
          
          # Parse JSON with jq
          SUITE=$(jq -r '.suite_name // "unknown"' ./results.json)
          PASSED=$(jq -r '.passed // 0' ./results.json)
          FAILED=$(jq -r '.failed // 0' ./results.json)
          ERRORS=$(jq -r '.errors // 0' ./results.json)
          SKIPPED=$(jq -r '.skipped // 0' ./results.json)
          
          # Determine status based on failures and errors
          if [ "$FAILED" -gt 0 ] || [ "$ERRORS" -gt 0 ]; then
            STATUS_DISPLAY="âŒ TESTS_FAILED"
          else
            STATUS_DISPLAY="âœ… TESTS_PASSED"
          fi
                    
          # Write to GitHub Step Summary
          if [ -n "$GITHUB_STEP_SUMMARY" ]; then
            {
              echo ""
              echo "## ðŸ“Š Test Execution Summary"
              echo ""
              echo '```'
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "  Execution Summary"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo ""
              echo "Suite Results:"
              echo ""
              printf "%-20s %-23s %-8s %-8s %-8s %-8s\n" "SUITE" "STATUS" "PASSED" "FAILED" "ERRORS" "SKIPPED"
              echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
              printf "%-20s %-23s %-8s %-8s %-8s %-8s\n" "$SUITE" "$STATUS_DISPLAY" "$PASSED" "$FAILED" "$ERRORS" "$SKIPPED"
              echo '```'
            } >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Save Docker logs
        if: always()
        run: |
          docker-compose logs alita-sdk > docker-logs.txt 2>&1 || echo "Failed to retrieve logs" > docker-logs.txt
      
      - name: Do AI analysis of logs
        if: always()
        run: |
          echo "::notice::Running AI analysis of test results"
          
          # Re-export all environment variables
          export DEPLOYMENT_URL="${{ secrets[format('DEPLOYMENT_URL_{0}', env.ENV_UPPER )] }}"
          export ALITA_API_KEY="${{ secrets[format('ALITA_API_KEY_{0}', env.ENV_UPPER )] }}"
          export PROJECT_ID="${{ secrets[format('PROJECT_ID_{0}', env.ENV_UPPER )] }}"
          export GIT_TOOL_ACCESS_TOKEN="${{ secrets.GIT_TOOL_ACCESS_TOKEN }}"
          export CONFLUENCE_API_KEY="${{ secrets.CONFLUENCE_API_KEY }}"
          export CONFLUENCE_BASE_URL="${{ secrets.CONFLUENCE_BASE_URL }}"
          export CONFLUENCE_USERNAME="${{ secrets.CONFLUENCE_USERNAME }}"
          export ADO_TOKEN="${{ secrets.ADO_TOKEN }}"
          export ADO_REPOSITORY_ID="${{ secrets.ADO_REPOSITORY_ID }}"
          export ADO_ORGANIZATION_URL="${{ secrets.ADO_ORGANIZATION_URL }}"
          export ADO_PROJECT="${{ secrets.ADO_PROJECT }}"
          export JIRA_API_KEY="${{ secrets.JIRA_API_KEY }}"
          export JIRA_USERNAME="${{ secrets.JIRA_USERNAME }}"
          export JIRA_BASE_URL="${{ secrets.JIRA_BASE_URL }}"
          export FIGMA_API_TOKEN="${{ secrets.FIGMA_API_TOKEN }}"
          export BITBUCKET_TOKEN="${{ secrets.BITBUCKET_TOKEN }}"
          export XRAY_CLIENT_SECRET="${{ secrets.XRAY_CLIENT_SECRET }}"
          export XRAY_CLIENT_ID="${{ secrets.XRAY_CLIENT_ID }}"
          export ZEPHYR_ESENTIALS_KEY="${{ secrets.ZEPHYR_ESENTIALS_KEY }}"
          export GITLAB_PRIVATE_TOKEN="${{ secrets.GITLAB_PRIVATE_TOKEN }}"
          export JIRA_PROJECT="EL"
          export TEST_CASES_DIR="${{ inputs.test_cases_dir}}"
          export ENVIRONMENT="${{ inputs.environment }}"
          export ENV_NAME="${{ inputs.environment }}"
          
          # Build the results path first
          RESULTS_PATH=".alita/tests/test_pipelines/test_results/suites/${{ inputs.test_cases_dir }}/results.json"
          
          # Set command with proper escaping for sh -c
          export DOCKER_COMMAND="alita agent run .alita/agents/test-fixer.agent.md --dir . \"Analyze ${RESULTS_PATH}\""
          
          docker-compose run --rm alita-sdk || echo "AI analysis completed with warnings"
          
      - name: Stop docker-compose
        if: always()
        run: docker-compose down --remove-orphans

      - name: Upload test results as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ inputs.test_cases_dir }}
          path: |
            ./results.html
            ./docker-logs.txt
          retention-days: 1

      - name: CLEAN UP WORKSPACE AFTER RUN
        if: always()
        run: |
          sudo rm -rf $GITHUB_WORKSPACE/{,.[!.],..?}*
