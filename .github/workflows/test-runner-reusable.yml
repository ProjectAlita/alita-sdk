name: Test Runner Reusable
run-name: Executing test for ${{ inputs.test_cases_dir }} on ${{ inputs.environment }} 

on:
  workflow_call:
    inputs:
      test_cases_dir:
        description: 'Test cases directory (e.g., github, ado, confluence)'
        required: true
        type: string
      environment:
        description: 'Environment to run tests in (local or other)'
        required: false
        type: string
        default: 'local'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test-execution:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Docker Compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull Docker image
        run: |
          IMAGE_NAME=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          docker pull ${{ env.REGISTRY }}/$IMAGE_NAME:pyodide

      - name: Calculate and run test command
        run: |
          ENV_FLAG=$([ "${{ inputs.environment }}" = "local" ] && echo "--local" || echo "")
          TEST_COMMAND="/app/.alita/tests/test_pipelines/run_all_suites.sh $ENV_FLAG -v suites/${{ inputs.test_cases_dir }}"
          
          echo "DOCKER_COMMAND_COMPOSED=$TEST_COMMAND" >> $GITHUB_ENV  
          echo "Running test command: $TEST_COMMAND"         

      - name: Uppercase the environment
        id: set-api-key
        run: |
          if [ "${{ inputs.environment }}" = "local" ]; then
            ENV_UPPER="DEV"
          else
            ENV_UPPER=$(echo "${{ inputs.environment }}" | tr '[:lower:]' '[:upper:]')
          fi
          echo "ENV_UPPER=${ENV_UPPER}" >> $GITHUB_ENV

      - name: Run docker-compose
        run: |
          echo "::notice::Starting docker-compose with command: ${{ env.DOCKER_COMMAND_COMPOSED }}"
          echo "::notice::On environment: ${{ env.ENV_UPPER }}"
          export DEPLOYMENT_URL="${{ secrets[format('DEPLOYMENT_URL_{0}', env.ENV_UPPER )] }}"
          export ALITA_API_KEY="${{ secrets[format('ALITA_API_KEY_{0}', env.ENV_UPPER )] }}"
          export PROJECT_ID="${{ secrets[format('PROJECT_ID_{0}', env.ENV_UPPER )] }}"
          export GIT_TOOL_ACCESS_TOKEN="${{ secrets.GIT_TOOL_ACCESS_TOKEN }}"
          export CONFLUENCE_API_KEY="${{ secrets.CONFLUENCE_API_KEY }}"
          export CONFLUENCE_BASE_URL="${{ secrets.CONFLUENCE_BASE_URL }}"
          export CONFLUENCE_USERNAME="${{ secrets.CONFLUENCE_USERNAME }}"
          export ADO_TOKEN="${{ secrets.ADO_TOKEN }}"
          export ADO_REPOSITORY_ID="${{ secrets.ADO_REPOSITORY_ID }}"
          export ADO_ORGANIZATION_URL="${{ secrets.ADO_ORGANIZATION_URL }}"
          export ADO_PROJECT="${{ secrets.ADO_PROJECT }}"
          export JIRA_API_KEY="${{ secrets.JIRA_API_KEY }}"
          export JIRA_USERNAME="${{ secrets.JIRA_USERNAME }}"
          export JIRA_BASE_URL="${{ secrets.JIRA_BASE_URL }}"
          export FIGMA_API_TOKEN="${{ secrets.FIGMA_API_TOKEN }}"
          export BITBUCKET_TOKEN="${{ secrets.BITBUCKET_TOKEN }}"
          export XRAY_CLIENT_SECRET="${{ secrets.XRAY_CLIENT_SECRET }}"
          export XRAY_CLIENT_ID="${{ secrets.XRAY_CLIENT_ID }}"
          export ZEPHYR_ESENTIALS_KEY="${{ secrets.ZEPHYR_ESENTIALS_KEY }}"
          export GITLAB_PRIVATE_TOKEN="${{ secrets.GITLAB_PRIVATE_TOKEN }}"
          export JIRA_PROJECT="EL"
          export TEST_CASES_DIR="${{ inputs.test_cases_dir}}"
          export ENVIRONMENT="${{ inputs.environment }}"
          export DOCKER_COMMAND="${{ env.DOCKER_COMMAND_COMPOSED }}"
          export ENV_NAME="${{ inputs.environment }}"
          docker-compose up -d

      - name: Wait for tests to complete
        id: wait_tests
        run: |
          echo "Waiting for test execution to complete..."
          
          TIMEOUT=10000
          ELAPSED=0
          INTERVAL=20
          CONTAINER_EXIT_CODE=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            STATUS=$(docker inspect alita-sdk-dev --format='{{.State.Status}}' 2>/dev/null || echo "not-found")
            
            if [ "$STATUS" = "exited" ]; then
              EXIT_CODE=$(docker inspect alita-sdk-dev --format='{{.State.ExitCode}}')
              CONTAINER_EXIT_CODE=$EXIT_CODE
              echo "Container exited with code: $EXIT_CODE"
              
              if [ "$EXIT_CODE" -eq 0 ]; then
                echo "âœ… Container completed successfully"
                echo "tests_failed=false" >> $GITHUB_OUTPUT
              else
                echo "âŒ Container exited with error code $EXIT_CODE"
                echo "tests_failed=true" >> $GITHUB_OUTPUT
              fi
              
              echo "Container logs:"
              docker-compose logs alita-sdk
              break
            elif [ "$STATUS" = "running" ]; then
              echo "Container still running... ($ELAPSED seconds elapsed)"
              echo "::group:: Current logs"
              docker-compose logs alita-sdk --tail=50
              echo "::endgroup::"
            else
              echo "Container status: $STATUS"
            fi
            
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "âš ï¸ Timeout reached after $TIMEOUT seconds"
            echo "tests_failed=true" >> $GITHUB_OUTPUT
            docker-compose logs alita-sdk
            exit 1
          fi
          
          if [ $CONTAINER_EXIT_CODE -ne 0 ]; then
            echo "::error::Tests failed with exit code $CONTAINER_EXIT_CODE"
            exit $CONTAINER_EXIT_CODE
          fi

      - name: Copy test results
        if: always()
        run: |
          docker cp alita-sdk-dev:/app/.alita/tests/test_pipelines/test_results/suites/${{ inputs.test_cases_dir }}/results.json ./results.json || echo "{}" > ./results.json
          
      - name: Generate test report
        if: always()
        run: |
          echo "Generating test report..."
          python .alita/tests/test_pipelines/scripts/generate_report.py ./results.json

      - name: Print execution summary
        if: always()
        id: test_summary
        run: |
          if [ ! -f ./results.json ]; then
            echo "âŒ No results.json found - tests may not have completed"
            if [ -n "$GITHUB_STEP_SUMMARY" ]; then
              echo "" >> "$GITHUB_STEP_SUMMARY"
              echo "## âŒ Test Results" >> "$GITHUB_STEP_SUMMARY"
              echo "" >> "$GITHUB_STEP_SUMMARY"
              echo "âŒ No results.json found - tests may not have completed" >> "$GITHUB_STEP_SUMMARY"
            fi
            exit 1
          fi
          
          # Parse JSON with jq
          SUITE=$(jq -r '.suite_name // "unknown"' ./results.json)
          PASSED=$(jq -r '.passed // 0' ./results.json)
          FAILED=$(jq -r '.failed // 0' ./results.json)
          ERRORS=$(jq -r '.errors // 0' ./results.json)
          SKIPPED=$(jq -r '.skipped // 0' ./results.json)
          
          # Determine status based on failures and errors
          if [ "$FAILED" -gt 0 ] || [ "$ERRORS" -gt 0 ]; then
            STATUS_DISPLAY="âŒ TESTS_FAILED"
          else
            STATUS_DISPLAY="âœ… TESTS_PASSED"
          fi
                    
          # Write to GitHub Step Summary
          if [ -n "$GITHUB_STEP_SUMMARY" ]; then
            {
              echo ""
              echo "## ðŸ“Š Test Execution Summary"
              echo ""
              echo '```'
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "  Execution Summary"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo ""
              echo "Suite Results:"
              echo ""
              printf "%-20s %-23s %-8s %-8s %-8s %-8s\n" "SUITE" "STATUS" "PASSED" "FAILED" "ERRORS" "SKIPPED"
              echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
              printf "%-20s %-23s %-8s %-8s %-8s %-8s\n" "$SUITE" "$STATUS_DISPLAY" "$PASSED" "$FAILED" "$ERRORS" "$SKIPPED"
              echo '```'
            } >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Save Docker logs
        if: always()
        run: |
          docker-compose logs alita-sdk > docker-logs.txt 2>&1 || echo "Failed to retrieve logs" > docker-logs.txt
      
      - name: Do AI analysis of logs
        if: ${{ always() && steps.wait_tests.outputs.tests_failed == 'true' }}
        run: |
          echo "::notice::Running AI analysis of test results"
          
          # Re-export all environment variables
          export DEPLOYMENT_URL="${{ secrets[format('DEPLOYMENT_URL_{0}', env.ENV_UPPER )] }}"
          export ALITA_API_KEY="${{ secrets[format('ALITA_API_KEY_{0}', env.ENV_UPPER )] }}"
          export PROJECT_ID="${{ secrets[format('PROJECT_ID_{0}', env.ENV_UPPER )] }}"
          export GIT_TOOL_ACCESS_TOKEN="${{ secrets.GIT_TOOL_ACCESS_TOKEN }}"
          export CONFLUENCE_API_KEY="${{ secrets.CONFLUENCE_API_KEY }}"
          export CONFLUENCE_BASE_URL="${{ secrets.CONFLUENCE_BASE_URL }}"
          export CONFLUENCE_USERNAME="${{ secrets.CONFLUENCE_USERNAME }}"
          export ADO_TOKEN="${{ secrets.ADO_TOKEN }}"
          export ADO_REPOSITORY_ID="${{ secrets.ADO_REPOSITORY_ID }}"
          export ADO_ORGANIZATION_URL="${{ secrets.ADO_ORGANIZATION_URL }}"
          export ADO_PROJECT="${{ secrets.ADO_PROJECT }}"
          export JIRA_API_KEY="${{ secrets.JIRA_API_KEY }}"
          export JIRA_USERNAME="${{ secrets.JIRA_USERNAME }}"
          export JIRA_BASE_URL="${{ secrets.JIRA_BASE_URL }}"
          export FIGMA_API_TOKEN="${{ secrets.FIGMA_API_TOKEN }}"
          export BITBUCKET_TOKEN="${{ secrets.BITBUCKET_TOKEN }}"
          export XRAY_CLIENT_SECRET="${{ secrets.XRAY_CLIENT_SECRET }}"
          export XRAY_CLIENT_ID="${{ secrets.XRAY_CLIENT_ID }}"
          export ZEPHYR_ESENTIALS_KEY="${{ secrets.ZEPHYR_ESENTIALS_KEY }}"
          export GITLAB_PRIVATE_TOKEN="${{ secrets.GITLAB_PRIVATE_TOKEN }}"
          export JIRA_PROJECT="EL"
          export TEST_CASES_DIR="${{ inputs.test_cases_dir}}"
          export ENVIRONMENT="${{ inputs.environment }}"
          export ENV_NAME="${{ inputs.environment }}"
          
          # Build the results path first
          RESULTS_PATH=".alita/tests/test_pipelines/test_results/suites/${{ inputs.test_cases_dir }}/results.json"
          
          format_branch() {
              echo "${1#refs/heads/}"
          }
          
          formated_branch=$(format_branch "${{ github.head_ref || github.ref }}")

          # Run without --rm to keep container for file extraction
          docker-compose run --name alita-sdk-fixer alita-sdk \
          sh -c "git config --global --add safe.directory /app && alita agent run .alita/agents/test-fixer.agent.md --dir . --message 'Analyze ${RESULTS_PATH} on ${{ inputs.environment }} and branch ${formated_branch}'" || echo "AI analysis completed with warnings"

      - name: Copy AI analysis outputs
        if: ${{ always() && steps.wait_tests.outputs.tests_failed == 'true' }}
        run: |
          echo "Copying fix analysis files from container..."
          docker cp alita-sdk-fixer:/app/.alita/tests/test_pipelines/test_results/suites/${{ inputs.test_cases_dir }}/fix_output.json ./fix_output.json || echo "{}" > ./fix_output.json
          docker cp alita-sdk-fixer:/app/.alita/tests/test_pipelines/test_results/suites/${{ inputs.test_cases_dir }}/fix_milestone.json ./fix_milestone.json || echo "{}" > ./fix_milestone.json
          
          echo "fix_output.json content:"
          cat ./fix_output.json
          
          # Remove the fixer container after copying files
          docker rm alita-sdk-fixer || true
          
      - name: Parse fix_output.json and check for blocked tests
        if: ${{ always() && steps.wait_tests.outputs.tests_failed == 'true' }}
        id: check_blocked
        run: |
          echo "Parsing fix_output.json for blocked tests..."
          
          # Check if file exists and is valid JSON
          if [ ! -f ./fix_output.json ]; then
            echo "fix_output.json not found"
            echo "bug_report_needed=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Parse blocked count
          BLOCKED_COUNT=$(jq -r '.summary.blocked // 0' ./fix_output.json)
          echo "Blocked tests count: $BLOCKED_COUNT"
          
          # Check if any blocked tests need bug reports
          if [ "$BLOCKED_COUNT" -gt 0 ]; then
            BUG_REPORT_NEEDED=$(jq -r '[.blocked[]? | select(.bug_report_needed == true)] | length > 0' ./fix_output.json)
            
            if [ "$BUG_REPORT_NEEDED" = "true" ]; then
              echo "::notice::Bug report needed for blocked tests"
              echo "bug_report_needed=true" >> $GITHUB_OUTPUT
              
              # Export blocked tests details for bug report
              jq -r '.blocked[]? | select(.bug_report_needed == true)' ./fix_output.json > blocked_tests_details.json
              echo "Blocked tests requiring bug reports:"
              cat blocked_tests_details.json
            else
              echo "bug_report_needed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "No blocked tests found"
            echo "bug_report_needed=false" >> $GITHUB_OUTPUT
          fi

      - name: Create bug reports for blocked tests
        if: ${{ always() && steps.wait_tests.outputs.tests_failed == 'true' && steps.check_blocked.outputs.bug_report_needed == 'true' }}
        run: |
          echo "::notice::Creating bug reports for blocked tests"
          
      - name: Stop docker-compose
        if: always()
        run: docker-compose down --remove-orphans

      - name: Upload test results as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ inputs.test_cases_dir }}
          path: |
            ./results.html
            ./docker-logs.txt
            ./fix_output.json
            ./fix_milestone.json
            ./blocked_tests_details.json
          retention-days: 1

      - name: CLEAN UP WORKSPACE AFTER RUN
        if: always()
        run: |
          sudo rm -rf $GITHUB_WORKSPACE/{,.[!.],..?}*
